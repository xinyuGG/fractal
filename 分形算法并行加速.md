# 分形算法并行加速

## 1. 代码分析

1.1 源代码剖析

代码主体部分：

```c++
for (int j = 0; j < H; ++j)
		for (int i = 0; i < W; ++i)
			bmp(j, i) = Mandelbrot(complex{RMIN + i / RESN, IMIN + j / RESN});
```

上述语句是两个for循环，最内层函数为：

```c++
int Mandelbrot(complex c) {
	complex z;
	for (int k = 256 * MI - 1; k >= 0; --k) {
		z = z * z + c;
		if (std::norm(z) > 4) return k / MI;
	}
	return 0;
}
```

内层函数是复数的乘加运算以及复数的模值判断。从中可以看出，嵌套for循环中的数据互不影响，以及核心运算是复数乘加运算。因此代码的优化可以从两方面入手：

- 将for循环展开，利用多个线程分别对一部分数据进行计算，可以近似获得线性加速
- 使用AVX指令优化复数乘法、加法运算

## 2. 优化方法

### 2.1 重新实现complex类

由于后续程序中可能对复数的乘加运算进行重新改写，因此首先重新试下了一下complex类，便于后续优化。

```c++
template<typename T>
class complex {
   	 	template<typename Ty>
    	friend Ty norm(const complex<Ty>& other);
    public:
        complex();
        complex(T real, T imag);
        complex(const complex&);
        complex& operator = (const complex&);
        complex& operator = (const T);
        complex& operator * (const complex&);
        complex& operator + (const complex&);
        bool operator == (const complex&);
        complex& squareAdd(const complex&);
        complex& assign(const T, const T);
    private:
        T _real;
        T _imag;
        T _placeholder;
};
//由于complex类中没有复杂的成员变量，所以就未实现移动构造函数。编译器应该也会对其做优化。
```

complex类的乘加方法简单实现，并未进行优化。

```c++
template<typename T>
inline complex<T>& complex<T>::operator + (const complex<T>& other) {
    _real += other._real;
    _imag += other._imag;
    return *this;
}

template<typename T>
inline complex<T>& complex<T>::operator * (const complex<T>& other) {
    auto tmp = _real * other._real - _imag * other._imag;
    _imag = _real * other._imag + _imag * other._real;
    _real = tmp;
    return *this;
}
```

### 2.2 循环展开

循环的实质是计算大矩阵的每一项的值，因此可以将矩阵按行分解，一个线程计算n行，随后获得硬件支持的最大线程数thread_num，根据总行数得到每个线程处理的行数。具体实现上，可以使用std::thread函数来做，这里我们采用std::async函数，使用二分策略对大矩阵进行分割。

主要代码如下：

```c++
template<typename Iterator> 
	static int Mandelbrot_pall(Iterator first, Iterator last, const int W, int H, const int index) {
		const unsigned long length = std::distance(first, last) ;
		if (!length)
			return 0;
		if (length <= W * SLICE)//确定最小分割值
		{
			Mandelbrot(first, W, index, SLICE);
			return 0;
		}
		else {
			int half_length = H / 2;
			Iterator mid = first + half_length * W;
			std::future<int> first_half = std::async(std::launch::async ,&Mandelbrot_pall<Iterator>, first, mid, W, half_length, index);
			Mandelbrot_pall<Iterator>(mid, last, W, H - half_length, index + half_length);
		}
	}
```

函数的参数W和H都可以通过计算得到，并且在迭代中，W保持不变，只对H进行分割，SLICE确定最小的H。当length不满足W * SLICE时，将当前线程所计算的行数二分，新线程中计算前半部分，当前线程计算后半部分。

当length满足最小行数时，就计算Mandelbrot函数，其定义如下：

```c++
template<typename Iterator>
static int Mandelbrot(Iterator first,const int W, const int index, const int h_num) {
	Iterator it = first;
	for (int h = 0; h < h_num; h++) {
		auto l_index = index + h;
		for (int i = 0; i < W; it++, i++) {
			*it = Mandelbrot(Complex(RMIN + i / RESN, IMIN + l_index / RESN));
		}
	}
	return 0;
}
```

重载的Mandelbrot计算函数定义如下：

```c++
static int Mandelbrot(Complex&& c) {
    Complex z;
    register int k;
    
    for (k = 256 * MI - 1; k >= 0; --k) {
#ifdef _MSC_VER
        z.squareAdd(c128);
#else
        z = z * z + c;
#endif
        if (Feng::norm(z) > 4) return k / MI;
    }
    return 0;
}
```

#ifdef是在windows下利用AVX指令对复数乘加运算进行优化，下文会提到。

### 2.3 使用AVX指令对复数乘加运算进行优化

complex.h中保留了我使用AVX指令对复数乘加运算进行优化的方法，但是实际使用时，发现进行了负优化。可能是编译器对计算的优化效果比较好，所以实际使用时把这段代码注释掉了。

## 3. 性能分析

在实际工作中，我首先在windows下进行了优化及性能测试，包括循环展开以及AVX优化，这期间我还下载了Intel的 parallel studio XE做性能分析，但是效果不太好。随后我转移到linux平台进行测试，并使用valgrind的cachegrind对cache命中情况作了分析。

因此 下文给出的数据都是在linux平台下得出的。

3.1 